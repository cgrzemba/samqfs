/*
 *	mtf.c - Make (and check) test files.
 */
/*
 *    SAM-QFS_notice_begin
 *
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License (the "License")
 * You may not use this file except in compliance with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */
/*
 * Copyright 2008 Sun Microsystems, Inc.  All rights reserved.
 * Use is subject to license terms.
 *
 *    SAM-QFS_notice_end
 */

/*
 * mtf generates and checks files of random data.  The files consist of
 * records of a selectable size.  The default size is 2084 (521 * 4) bytes.
 * Each record contains the name of the file and the record number followed
 * by random integers to fill out the record.
 *
 * In addition, the first record contains the record size,
 * the random number seed and the data length.  This format allows the file
 * data to be checked later knowing only the file name.
 *
 * The file is written using a selectable buffer size.  The default size is
 * 41 records.  The default buffer and record size values, 41 and 521
 * (which are prime numbers), avoids performing I/O in integer multiples of
 * sector and block sizes.
 *
 * File names may be generated by using the regular expression "range"
 * construction [x-y].  When such a filename argument is used, each range
 * construction, from right to left, is successively incremented.
 *
 * For example, the file name "file[A-C][0-9]" generates the file names
 * fileA0 through fileC9.
 *
 * Note, you need to "shell escape" the range constructions.
 *
 * If the -R option is not selected, and one of the files to be generated
 * already exists, that file name is skipped.
 *
 * Usage: ./mtf
 *  [-B record_size[-number_of_records] ] -- Write data in 'record_size'
 *      records.
 *      Use a buffer of 'number_of_records' * 'record_size' bytes
 *      Default record_size = 2084, number_of_records = 41
 *  [-R] -- Allow rewriting of existing file
 *  [-S seed] -- Set random seed
 *  [-c] -- Check files
 *  [-d dirname] -- Set starting directory (default is current)
 *  [-g] -- Generate files (default action)
 *  [-f] -- Do not stop on errors
 *  [-i] [b | d | m] -- Use buffer | direct | mmap I/O
 *  [-s min[-max] ] -- File size minimum and maximums
 *      'k', 'M', 'G', 'T' multipliers.  e.g. 2.43G
 *      Default 'min' = 14588, 'max' = 'min'
 *  [-v] -- Verbose - print buffer parameters and timings
 *  file ...
 *      'file' may have regular expression-like '[a-z]' for generation of
 *      file names
 *      If 'file' is '-', read a list of files from the standard input.
 *
 */

/* ANSI C headers. */
#include <errno.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/* POSIX headers. */
#include <sys/types.h>
#include <fcntl.h>
#include <unistd.h>
#include <utime.h>
#include <sys/stat.h>

/* Solaris headers. */
#include <sys/time.h>
#include <sys/mman.h>

/* Macros. */
#define	MAXPATHLEN 1024
#define	REC_SIZE 521 * 4	/* Default number of bytes in a record */
#define	REC_NUMOF 41		/* Default number of records in a buffer */

/* Types. */
typedef enum { FALSE, TRUE } bool;  /* boolean */
typedef unsigned char uint8;
typedef long int32;
typedef unsigned long uint32;
typedef long long int64;
typedef unsigned long long uint64;
static enum IoMode {
	IM_none,
	IM_buffer,
	IM_direct,
	IM_mmap,
	IM_max
} IoMode = IM_buffer;

/* Structures. */
static struct FileHeader {
	uint32	RecordSize;
	uint32	FileSeed;		/* Random number seed */
	int64	FileSize;		/* File size */
} FileHeader;

/* Private data. */
static bool Chk = FALSE;
static bool Debug = FALSE;
static bool Gen = FALSE;
static bool Quiet = FALSE;
static bool Rewrite = FALSE;
static bool Verbose = FALSE;

static uint8 *Buffer;
static uint8 *cp_buffer;
static char fullpath[MAXPATHLEN + 4];	/* Current full path name */
static char dir_name[sizeof (fullpath)];	/* Directory name */
static char *program_name;
static size_t BufferSize;
static int exit_status = 0;
static int RecordNumof = REC_NUMOF;
static int64 FileSizeRange[2] =		/* Minimum, maximum file size */
	{ 0, 0 };
static int64 NextXfr;			/* Next transfer for progress graph */
static size_t RecordSize = REC_SIZE;
static size_t name_l;			/* Len of name in fullpath rounded */
static uint32 seed = 0;

/* Private functions. */
static void AsmSize(char *token, int64 *size);
static void Assert(int LineNum);
static char *CountToA(int64 v);
static int CreateFile(void);
static void DisplayProgress(int64 BytesXfred);
static void DoName(char *basename);
static void DoStdin(void);
static char *FsizeToA(int64 v);
static int MakeDirs(char *path);
static char *NormalizePath(char *path);
static void PrintInfo(char *name, struct FileHeader *f);
static void PrintRecord(int RecordNumber, uint64 offset, uint8 *bf);
static void ReadFile(void);
static void WriteFile(void);
static void prerror(int status, int prerrno, char *fmt, ...);


/* Function macros. */
#define	ASSERT(cond) if (!(cond)) Assert(__LINE__);
#define	numof(a) (sizeof (a) / sizeof (*(a)))


int
main(int argc, char *argv[])
{
	bool	FileSizeSet = FALSE;
	int		c;
	int		errors;
	double	dv;

	program_name = argv[0];
	getcwd(dir_name, sizeof (dir_name)-1);

	errors = 0;
	while ((c = getopt(argc, argv, "B:RS:cd:fgi:s:v")) != EOF) {
		switch (c) {
		case 'B':	{ /* record/buffer size */
			char	*p;
			int64	value;

			if ((p = strchr(optarg, '-')) != NULL)  *p++ = '\0';
			AsmSize(optarg, &value);
			if (value < sizeof (uint64)) {
				errors++;
				fprintf(stderr,
				    "Record size must be: %d > size < %d\n",
				    sizeof (uint64), 1 << 30);
			}
			RecordSize = (uint32)value;
			if (p != NULL) {
				AsmSize(p, &value);
				RecordNumof = (int)value;
			} else  RecordNumof = 32;
			}
			break;
		case 'R':	/* Rewrite */
			Rewrite = TRUE;
			break;
		case 'S':	/* random seed */
			seed = strtol(optarg, NULL, 0);
			srand48(seed);
			break;
		case 'c':	/* check */
			Chk = TRUE;
			break;
		case 'd':	/* base directory */
			strncpy(dir_name, optarg, sizeof (dir_name)-4);
			break;
		case 'f':	/* do not stop on errors */
			Quiet = TRUE;
			break;
		case 'g':	/* generate */
			Gen = TRUE;
			break;
		case 'i':	/* I/O mode */
			switch (*optarg) {
			case 'b':
				IoMode = IM_buffer;
				break;
#if defined(DIRECTIO_ON)
			case 'd':
				IoMode = IM_direct;
				break;
#endif /* defined(DIRECTIO_ON) */
			case 'm':
				IoMode = IM_mmap;
				break;
			default:
				errors++;
#if defined(DIRECTIO_ON)
				fprintf(stderr,
				    "I/O mode must be b, d, or m\n");
#else /* defined(DIRECTIO_ON) */
				fprintf(stderr, "I/O mode must be b or m\n");
#endif /* defined(DIRECTIO_ON) */
				break;
			}
			break;
		case 's': {	/* size */
			char	*p;

			if ((p = strchr(optarg, '-')) != NULL)  *p++ = '\0';
			AsmSize(optarg, &FileSizeRange[0]);
			if (p != NULL)  AsmSize(p, &FileSizeRange[1]);
			FileSizeSet = TRUE;
			}
			break;
		case 'v':	/* verbose */
			Verbose = TRUE;
			break;
		case '?':
		default:
			errors++;
			break;
		}
	}

	if (errors != 0 || (argc - optind) < 1) {
		fprintf(stderr,
"Usage: %s \n", program_name);
		fprintf(stderr,
"  [-B record_size[-number_of_records] ] -- Write data in 'record_size' "
		    "records\n");
		fprintf(stderr,
"      Use a buffer of 'number_of_records' * 'record_size' bytes\n");
		fprintf(stderr,
"      Default record_size = %d, number_of_records = %d\n",
		    REC_SIZE, REC_NUMOF);
		fprintf(stderr,
"  [-R] -- Allow rewriting of existing file\n");
		fprintf(stderr,
"  [-S seed] -- Set random seed\n");
		fprintf(stderr,
"  [-c] -- Check files\n");
		fprintf(stderr,
"  [-d dirname] -- Set starting directory (default is current)\n");
		fprintf(stderr,
"  [-g] -- Generate files (default action)\n");
		fprintf(stderr,
"  [-f] -- Do not stop on errors\n");
#if defined(DIRECTIO_ON)
		fprintf(stderr,
"  [-i] [b | d | m] -- Use buffer | direct | mmap I/O\n");
#else /* defined(DIRECTIO_ON) */
		fprintf(stderr,
"  [-i] [b | m] -- Use buffer | mmap I/O\n");
#endif /* defined(DIRECTIO_ON) */
		fprintf(stderr,
"  [-s min[-max] ] -- File size minimum and maximums\n");
		fprintf(stderr,
"      'k', 'M', 'G', 'T' multipliers.  e.g. 2.43G\n");
		fprintf(stderr,
"      Default 'min' = %d, 'max' = 'min'\n", 7 * RecordSize);
		fprintf(stderr,
"  [-v] -- Verbose - print buffer parameters and timings\n");
		fprintf(stderr,
"  file ...\n");
		fprintf(stderr,
"      'file' may have regular expression-like '[a-z]' for generation of\n");
		fprintf(stderr,
"      file names\n");
		exit(2);
	}

	if (!FileSizeSet) {
		FileSizeRange[0] = 7 * RecordSize;
	}
	if (!Gen && !Chk)  Gen = TRUE;
	if (IoMode != IM_mmap) {
		BufferSize = RecordNumof * RecordSize;
		if ((Buffer = (uint8 *)malloc(BufferSize)) == NULL) {
			prerror(2, 0, "malloc(%d) failed", BufferSize);
		}
	} else {
		BufferSize = 0;
		Buffer = NULL;
	}
	if ((cp_buffer = (uint8 *)malloc(RecordSize)) == NULL) {
		prerror(2, 0, "malloc(%d) failed", RecordSize);
	}
	dv = drand48();
	seed = (*(uint64 *)&dv) >> 17;

	if (Verbose) {
		char	*mode;

		if (Debug)  printf("Debug on\n");
		switch (IoMode) {
		case IM_buffer:  mode = "buffer"; break;
		case IM_direct:  mode = "direct"; break;
		case IM_mmap:  mode = "mmap"; break;
		default:  mode = "??"; break;
		}
		printf("Using %s I/O: %s bytes/record", mode,
		    CountToA(RecordSize));
		printf(", %s byte buffer\n", CountToA(BufferSize));
	}

	while (optind < argc) {
		if (strcmp(argv[optind], "-") == 0) {
			DoStdin();
		} else {
			DoName(argv[optind]);
		}
		optind++;
	}
	return (exit_status);
}


/*
 *	Assemble size.
 *	Size string in token.
 */
static void
AsmSize(char *token, int64 *size)
{
	char	*p;
	double	conv;
	double	frac;
	int64	value;

	p = token;
	conv = strtod(token, &p);
	value = (int64)conv;
	frac = conv - (double)value;
	if (value < 0 || p == token)  prerror(2, 0, "Invalid size %s", token);
	if ('b' == *p) {
		p++;
		if (frac != 0)  prerror(2, 0, "Invalid size %s", token);
	} else if ('k' == *p) {
		p++;
		value *= 1024;
		frac  *= 1024;
	} else if ('M' == *p) {
		p++;
		value *= 1024 * 1024;
		frac  *= 1024 * 1024;
	} else if ('G' == *p) {
		p++;
		value *= 1024 * 1024 * 1024;
		frac  *= 1024 * 1024 * 1024;
	} else if ('T' == *p) {
		p++;
		value *= (uint64)1024 * 1024 * 1024 * 1024;
		frac  *= (uint64)1024 * 1024 * 1024 * 1024;
	} else if (frac != 0)  prerror(2, 0, "Invalid size %s", token);
	if (*p != '\0')  prerror(2, 0, "Invalid size %s", token);
	*size = (int64)(value + frac);
}


/*
 * Create the file to be written.
 * If more than one file is on the command line, or file names are being
 * generated, the file must not exist.
 */
static int			/* open file descriptor; -1 if failed */
CreateFile(void)
{
	bool	first;
	int		fd;
	int		oflag;

	first = TRUE;
	if (IoMode == IM_mmap)  oflag = 0;
	else {
		oflag = O_CREAT;
		if (!Rewrite)  oflag |= O_EXCL;
		else  oflag |= O_TRUNC;
	}
#if defined(O_LARGEFILE)
	oflag |= O_LARGEFILE;
	if (Debug)  printf("Creating O_LARGEFILE\n");
#endif

retry:
	if ((fd = open(fullpath, O_RDWR | oflag, 0666)) == -1) {
		if (first && ENOENT == errno) {
			if (IoMode == IM_mmap) {
				prerror(1, 0,
				    "Can not mmap write non-existent file");
				return (-1);
			}
			/*
			 * Make required directory components if components
			 * don't exist on the first try.
			 */
			first = FALSE;
			if (MakeDirs(fullpath) != -1)  goto retry;
			errno = ENOENT;
		}
		prerror(1, 1, "Cannot create %s", fullpath);
		return (-1);
	}
	return (fd);
}


/*
 *	Process a name.
 */
static void
DoName(char *name)
{
	struct {
		char	*ch;
		char	first;
		int		range;
	} gen_chars[32];
	char	*fp;
	char	*p;
	int		gc;
	int		n;

	if (*name != '/') {
		/* Start with dir_name. */
		strcpy(fullpath, dir_name);
		fp = fullpath + strlen(fullpath);
		*fp++ = '/';
	} else  fp = fullpath;
	strcpy(fp, name);
	if (NormalizePath(fullpath) == NULL) {
		prerror(2, 0, "Invalid file name.");
		return;
	}

	/*
	 * Process "[...]" fields.
	 */
	gc = 0;
	while ((p = strchr(fp, '[')) != NULL) {
		gen_chars[gc].ch = p++;
		if (']' == *p) {
			prerror(2, 0, "Empty [].");
			return;
		}
		gen_chars[gc].first = *p++;
		if ('-' == *p) {
			p++;
			gen_chars[gc].range = *p++ - gen_chars[gc].first;
			if (gen_chars[gc].range < 0) {
				prerror(2, 0, "[] range reversed.");
				return;
			}
		} else  gen_chars[gc].range = 0;
		if (*p++ != ']') {
			prerror(2, 0, "Missing ].");
			return;
		}
		*gen_chars[gc].ch = gen_chars[gc].first;
		fp = gen_chars[gc].ch+1;
		strcpy(fp, p);
		if (gen_chars[gc].range > 0) {
			gc++;
			if (gc >= numof(gen_chars)) {
				prerror(2, 0, "Too many []s");
				return;
			}
		}
	}

	/*
	 * Compute length of fullpath rounded to a multiple of sizeof (uint32).
	 */
	name_l = strlen(fullpath) + 1;
	p = &fullpath[name_l];
	n = name_l % sizeof (uint32);
	if (n != 0) {
		n = sizeof (uint32) - n;
		name_l += n;
		while (n-- > 0)  *p++ = '\0';
	}

	/*
	 * Now perform the action for all files defined.
	 */
	for (;;) {
		if (Gen)  WriteFile();
		if (Chk)  ReadFile();

		/*
		 * Increment each character through its range.
		 */
		for (n = gc-1; ; n--) {
			char	ch;

			if (n < 0)
				return;
			ch = ++*gen_chars[n].ch;
			if ((ch <= gen_chars[n].first + gen_chars[n].range))
				break;
			*gen_chars[n].ch = gen_chars[n].first;
		}
	}
}


/*
 * Read file names from standard input.
 */
static void
DoStdin(void)
{
	static char fname[MAXPATHLEN];

	/*
	 * Read file names from STDIN.
	 */
	while (fgets(fname, sizeof (fname), stdin) != NULL) {
		int		l;

		if ((l = strlen(fname)) == 0) {
			continue;
		}
		fname[l - 1] = '\0';
		if (*fname != '/') {
			/* Start with dir_name. */
			snprintf(fullpath, sizeof (fullpath), "%s/%s",
			    dir_name, fname);
		} else {
			memcpy(fullpath, fname, l);
		}
		if (Gen) {
			WriteFile();
		}
		if (Chk) {
			ReadFile();
		}
	}
}


/*
 *	Check a file.
 */
static void
ReadFile(void)
{
	struct timeval start;
	bool	mapped;
	int64	SizeRead;
	uint32	seed;
	int		fd, RecordNumber;
	int		oflag;

	seed = 0;
	oflag = O_RDONLY;
#if defined(O_LARGEFILE)
	oflag |= O_LARGEFILE;
	if (Debug)  printf("Reading O_LARGEFILE\n");
#endif
	if ((fd = open(fullpath, oflag)) == -1) {
		prerror(1, 1, "Cannot open %s", fullpath);
		return;
	}

	mapped = FALSE;
	switch (IoMode) {
	case IM_buffer:
		ASSERT(Buffer != NULL);
		break;

#if defined(DIRECTIO_ON)
	case IM_direct:
		ASSERT(Buffer != NULL);
		if (directio(fd, DIRECTIO_ON) == -1) {
			prerror(1, 1, "directio(%s, DIRECTIO_ON)", fullpath);
			goto out;
		}
		break;
#endif /* defined(DIRECTIO_ON) */

	case IM_mmap: {
		struct stat st;

		if (fstat(fd, &st) == -1) {
			prerror(1, 1, "fstat(%s)", fullpath);
			goto out;
		}
		BufferSize = st.st_size;
		Buffer = (uint8 *)mmap(
		    NULL, BufferSize, PROT_READ, MAP_PRIVATE, fd, 0);
		if (Buffer == MAP_FAILED) {
			prerror(1, 1, "mmap(%s)", fullpath);
			goto out;
		}
		mapped = TRUE;
		}
		break;

	default:
		ASSERT(IoMode != IM_buffer);
		break;
	}


	/*
	 * Read and check the file data.
	 */
	FileHeader.FileSize = BufferSize;
	RecordNumber = 1;
	SizeRead = 0;
	NextXfr = 0;
	gettimeofday(&start, NULL);
	while (SizeRead < FileHeader.FileSize) {
		uint8	*bf;
		uint8	*bf_end;
		int		BytesRead;

		if (IoMode != IM_mmap) {
			int	l;

			l = BufferSize;
			if (SizeRead + l >= FileHeader.FileSize) {
				l = FileHeader.FileSize - SizeRead;
			}
			if ((BytesRead = read(fd, Buffer, l)) < 0) {
				prerror(1, 1, "Cannot read %s, offset %lld",
				    fullpath,
				    SizeRead);
				goto out;
			}
			if (BytesRead != l) {
				if (RecordNumber != 1 ||
				    BytesRead < (name_l +
				    sizeof (FileHeader))) {
					prerror(1, 0,
					    "Record too short %d < %d",
					    BytesRead, l);
					goto out;
				}
			}
		} else  BytesRead = BufferSize;

		bf = Buffer;
		bf_end = Buffer + BytesRead;
		while (bf < bf_end) {
			uint8	*bf_start;
			uint32	*d, *d_end;
			uint32	dv;

			/*
			 * Verify file name.
			 */
			bf_start = bf;
			if (memcmp(bf, fullpath, name_l) != 0) {
				if (bf + name_l <= bf_end) {
					prerror(0, 0,
					    "%s: record %d,  file name wrong",
					    fullpath,
					    RecordNumber);
					PrintRecord(RecordNumber, SizeRead,
					    bf);
				}
				goto out;
			}
			bf += name_l;
			if (RecordNumber == 1) {
				/*
				 * Record 1 contains the FileHeader.
				 */
				memcpy(&FileHeader, bf, sizeof (FileHeader));
				seed = FileHeader.FileSeed;
				bf += sizeof (FileHeader);
			}

			/*
			 * Set end of data.
			 */
		/* LINTED pointer cast may result in improper alignment */
			d_end = (uint32 *)(bf_start + FileHeader.RecordSize);
		/* LINTED pointer cast may result in improper alignment */
			if ((uint8 *)d_end > bf_end)  d_end = (uint32 *)bf_end;

			/*
			 * Verify data.
			 */
		/* LINTED pointer cast may result in improper alignment */
			d = (uint32 *)bf;
			if (*d != RecordNumber) {
				if ((d + 1) <= d_end) {
					prerror(0, 0,
					    "%s: record %d, record number "
					    "wrong: %d",
					    fullpath, RecordNumber, *d);
					PrintRecord(RecordNumber, SizeRead,
					    bf);
				}
				goto out;
			}
			RecordNumber++;
			d++;
			dv = seed;
			while (d < d_end) {
				dv = 3141592621U * dv + 2818281829U;
				if (*d != dv) {
					if ((d + 1) <= d_end) {
						prerror(0, 0,
						    "%s: record %d, data "
						    "error", fullpath,
						    RecordNumber);
						PrintRecord(RecordNumber,
						    SizeRead, bf);
						goto out;
					}
				}
				d++;
			}
			seed = dv;
			bf = (uint8 *)d_end;
		}
		SizeRead += BytesRead;
		if (Verbose)  DisplayProgress(SizeRead);
	}
	if (Verbose) {
		struct timeval now;
		double	tn, ts;

		gettimeofday(&now, NULL);
		ts = (double)start.tv_sec +
		    ((double)start.tv_usec / 10000000.);
		tn = (double)now.tv_sec + ((double)now.tv_usec / 10000000.);
		PrintInfo(fullpath, &FileHeader);
		printf("  %s records read", CountToA(RecordNumber - 1));
		printf(", %s (%s) bytes read", FsizeToA(SizeRead),
		    CountToA(SizeRead));
		printf(", %.3f seconds\n", tn - ts);
	}
out:
	if (mapped) {
		(void) munmap((char *)Buffer, BufferSize);
	}
	(void) close(fd);
}


/*
 * ---- CheckWriteSize
 *
 * Given a file descriptor, a file length, and a length (supposedly)
 * written, verify that the file's actual length is the sum of the
 * file length and the length written.
 */
static void
CheckWriteSize(
	int fd,
	int64_t size,
	size_t len)
{
	struct stat st;

	if (fstat(fd, &st) == -1) {
		prerror(1, 1, "fstat(%s)", fullpath);
		return;
	}
	if (size + len == st.st_size) {
		printf("Size OK: %lld bytes\n", (long long)size + len);
	} else {
		printf("Size Bad: %lld bytes (!= %lld)\n",
		    (long long)st.st_size, (long long)size + len);
	}
}


/*
 *	Generate a file.
 */
static void
WriteFile(void)
{
	struct timeval start;
	bool	mapped;
	int64	SizeWritten;
	int		fd;
	long	RecordNumber;

	if ((fd = CreateFile()) == -1)
		return;

	mapped = FALSE;
	FileHeader.FileSize = FileSizeRange[0];
	if (FileSizeRange[1] != 0) {
		FileHeader.FileSize +=
		    (FileSizeRange[1] - FileSizeRange[0]) * drand48();
	}
	if (FileHeader.FileSize == 0) {
		goto out;
	}
	FileHeader.RecordSize	= RecordSize;
	FileHeader.FileSeed		= seed;

	switch (IoMode) {
	case IM_buffer:
		ASSERT(Buffer != NULL);
		break;

#if defined(DIRECTIO_ON)
	case IM_direct:
		ASSERT(Buffer != NULL);
		if (directio(fd, DIRECTIO_ON) == -1) {
			prerror(1, 1, "directio(%s, DIRECTIO_ON)", fullpath);
			goto out;
		}
		break;
#endif /* defined(DIRECTIO_ON) */

	case IM_mmap: {
		struct stat st;

		if (fstat(fd, &st) == -1) {
			prerror(1, 1, "fstat(%s)", fullpath);
			goto out;
		}
		BufferSize = st.st_size;
		if (BufferSize == 0) {
			prerror(1, 0, "Can not mmap write to empty file.");
			goto out;
		}
		Buffer = (uint8 *)mmap(
		    NULL, BufferSize, PROT_WRITE, MAP_PRIVATE, fd, 0);
		if (Buffer == MAP_FAILED) {
			prerror(1, 1, "mmap(%s)", fullpath);
			goto out;
		}
		mapped = TRUE;
		}
		break;

	default:
		ASSERT(IoMode != IM_buffer);
		break;
	}


	/*
	 * Write the file data.
	 */
	gettimeofday(&start, NULL);
	RecordNumber = 1;
	SizeWritten = 0;
	while (SizeWritten < FileHeader.FileSize) {
		uint8	*bf;
		int		bf_size;
		int		writeRecord;

		/*
		 * Fill buffer with records.
		 */
		bf = Buffer;
		writeRecord = RecordSize;
		for (bf_size = 0; bf_size < BufferSize;
		    bf_size += writeRecord) {
			uint32 *d, *d_end;

			/*
			 * Create a record.
			 * File name, record number, random data.
			 */
			if ((bf_size + writeRecord) > BufferSize) {
				writeRecord = BufferSize - bf_size;
			}
		/* LINTED pointer cast may result in improper alignment */
			d_end = (uint32 *)(bf + writeRecord);
			memcpy(bf, fullpath, name_l);
			bf += name_l;
			if (RecordNumber == 1) {
				/*
				 * First record includes the FileHeader.
				 */
				memcpy(bf, &FileHeader, sizeof (FileHeader));
				bf += sizeof (FileHeader);
			}
		/* LINTED pointer cast may result in improper alignment */
			d = (uint32 *)bf;
			*d++ = RecordNumber++;
			while (d < d_end) {
				*d++ = seed = 3141592621U * seed + 2818281829U;
			}
			bf = (uint8 *)d_end;
			if (SizeWritten + bf_size >= FileHeader.FileSize) {
				bf_size = FileHeader.FileSize - SizeWritten;
				break;
			}
		}
		if (IoMode != IM_mmap) {
			size_t n;
			char *b = (char *)&Buffer[0];

			if ((n = write(fd, b, bf_size)) != bf_size) {
				int e = 0;
				size_t nr;

				if (n == (size_t)-1) {
					e = errno;
				}
				if (e) {
					prerror(0, e, "Failed write %s, "
					    "offset %lld, len=%ld/%ld",
					    fullpath,
					    (long long)SizeWritten,
					    (long)n, (long)bf_size);
				} else {
					prerror(0, e, "Short write %s, "
					    "offset %lld, len=%ld/%ld",
					    fullpath, (long long)SizeWritten,
					    (long)n, (long)bf_size);
				}
				CheckWriteSize(fd, SizeWritten, e ? 0 : n);

				if (e) {
					goto out;
				}

				/*
				 * Short write, no error:  try to write
				 * remainder of buffer
				 */
				SizeWritten += n;
				if ((nr = write(fd, &b[n], bf_size - n)) !=
				    bf_size - n) {
					e = 0;
					if (nr == (size_t)-1) {
						e = errno;
					}
					prerror(0, e,
					    "Rewrite failed; %s, "
					    "offset %lld, len=%ld/%ld",
					    fullpath,
					    (long long)SizeWritten + n,
					    (long)nr, (long)bf_size - n);
				}

				CheckWriteSize(fd, SizeWritten, e ? 0 : nr);

				if (e) {
					goto out;
				}

				SizeWritten += nr;
			} else {
				SizeWritten += n;
			}
		} else {
			SizeWritten += bf_size;
		}
		if (Verbose)  DisplayProgress(SizeWritten);
	}

	if (Verbose) {
		struct timeval now;
		double	tn, ts;

		gettimeofday(&now, NULL);
		ts = (double)start.tv_sec +
		    ((double)start.tv_usec / 10000000.);
		tn = (double)now.tv_sec + ((double)now.tv_usec / 10000000.);
		PrintInfo(fullpath, &FileHeader);
		printf("  %s records written", CountToA(RecordNumber - 1));
		printf(", %s (%s) bytes written", FsizeToA(SizeWritten),
		    CountToA(SizeWritten));
		printf(", %.3f seconds\n", tn - ts);
	}

out:
	if (mapped) {
		(void) munmap((char *)Buffer, BufferSize);
	}
	if (close(fd) == -1) {
		prerror(1, 1, "Cannot close %s", fullpath);
	}
}


/*
 * Display progress.
 */
static void
DisplayProgress(int64 BytesXfred)
{
	static char BarGraph[23] = "|                    |";
	static char		*Bar;
	static int64	FivePct;
	static int64	MaxSize;
	static int64	NextSize;

	/*
	 * Reset bar graph.
	 */
	if (NextXfr == 0) {
		Bar = BarGraph + 1;
		memset(Bar, ' ', 20);
		FivePct = FileHeader.FileSize / 20;
		MaxSize = 20 * FivePct;
		NextSize = FivePct;
	}
	if (BytesXfred > MaxSize)
		BytesXfred = MaxSize;
	if (BytesXfred < NextSize)
		return;
	while (NextSize <= BytesXfred) {
		NextSize += FivePct;
		*Bar++ = '*';
	}
	printf("%s\r", BarGraph);
	fflush(stdout);
}


/*
 *	Make missing directory components.
 */
static int
MakeDirs(char *path)
{
	size_t	len;

	/*
	 * Back up through the components until mkdir succeeds.
	 */
	len = strlen(path);
	for (;;) {
		char	*p;

		p = strrchr(path, '/');
		if (NULL == p || p == path)
			return (-1);
		*p = '\0';
		errno = 0;
		if (mkdir(path, 0777) == 0)
			break;
		if (errno != ENOENT)
			return (-1);
	}

	/*
	 * Come forward through the components to the original name.
	 */
	path[strlen(path)] = '/';
	while (strlen(path) < len) {
		if (mkdir(path, 0777) != 0)
			return (-1);
		path[strlen(path)] = '/';
	}
	return (0);
}


/*
 *	Normalize path.
 *	Remove ./ ../ // sequences in a path.
 *	Note: path array must be able to hold one more character.
 */
char *
NormalizePath(char *path)		/* Path to be normalized. */
{
	char	*p, *ps, *q;

	ps = path;
	/* Preserve an absolute path. */
	if ('/' == *ps)  ps++;

	strcat(ps, "/");
	p = q = ps;
	while (*p != '\0') {
		char	*q1;

		if ('.' == *p) {
			if ('/' == p[1]) {
				/*
				 * Skip "./".
				 */
				p++;
			} else if ('.' == p[1] && '/' == p[2]) {
				/*
				 * "../"  Back up over previous component.
				 */
				p += 2;
				if (q <= ps)
					return (NULL);
				q--;
				while (q > ps && q[-1] != '/')  q--;
			}
		}
		/*
		 * Copy a component.
		 */
		q1 = q;
		while (*p != '/')  *q++ = *p++;
		if (q1 != q) *q++ = *p;
		/*
		 * Skip successive '/'s.
		 */
		while ('/' == *p)  p++;
	}
	if (q > ps && '/' == q[-1])  q--;
	*q = '\0';
	return (path);
}


/*
 *	Print file information.
 */
static void
PrintInfo(
	char *name,
	struct FileHeader *f)
{
	printf("%s FileSize:%s (%s) seed:%lu\n", name, FsizeToA(f->FileSize),
	    CountToA(f->FileSize), f->FileSeed);
}


/*
 *	Process a record error.
 */
static void
PrintRecord(
	int RecordNumber,
	uint64 offset,
	uint8 *bf)
{
	uint8	*cp;
	int		n, nb, nw;
	uint32	*d, *d_end, dv;

	/*
	 * Re-create the record.
	 */
	cp = cp_buffer;
/* LINTED pointer cast may result in improper alignment */
	d_end = (uint32 *)(cp + RecordSize);
	memcpy(cp, fullpath, name_l);
/* LINTED pointer cast may result in improper alignment */
	d = (uint32 *)(cp + name_l);
	*d++ = RecordNumber;
	dv = seed;
	while (d < d_end) {
		*d++ = dv = 3141592621U * dv + 2818281829U;
	}
	offset += sizeof (struct FileHeader) + name_l;
	fprintf(stderr, " Offset: %lld (0x%llx)\n", offset, offset);

	/*
	 * Print out comparison.
	 */
	nb = 16;
	for (nw = 0; nw < RecordSize; nw += nb) {
		if ((nw + 4) > RecordSize)  nb = (RecordSize - nw) * 4;
		if (memcmp(cp, bf, nb) == 0) {
			cp += nb;
			bf += nb;
			continue;
		}

		fprintf(stderr, "%04lx:",
		    (uint32)((offset + (nw << 2)) & 0xffff));

		/*
		 * Should be.
		 */
		for (n = 0; n < nb; n++) {
			if ((n & 3) == 0)  fprintf(stderr, " ");
			fprintf(stderr, "%02x ", *cp++);
		}
		fprintf(stderr, "\n     ");

		/*
		 * Is.
		 */
		for (n = 0; n < nb; n++) {
			if ((n & 3) == 0)  fprintf(stderr, " ");
			fprintf(stderr, "%02x ", *bf++);
		}
		fprintf(stderr, "\n     ");

		/*
		 * Exclusive or.
		 */
		cp -= nb;
		bf -= nb;
		for (n = 0; n < nb; n++) {
			uint8	bd;

			if ((n & 3) == 0)  fprintf(stderr, " ");
			bd = *bf++ ^ *cp++;
			if (bd != 0)  fprintf(stderr, "%02x ", bd);
			else  fprintf(stderr, "   ");
		}
		fprintf(stderr, "\n");
	}
}


/*
 * Process failed assertion.
 */
static void
Assert(int LineNum)
{
	fprintf(stderr, "Assertion failed at line %d\n", LineNum);
	abort();
}


/*
 *	Return pointer to comma separated count conversion.
 */
static char *
CountToA(int64 v)		/* Value to convert. */
{
	static	char buf[32];
	char	*p;
	int		NumofDigits;

	p = buf + sizeof (buf) - 1;
	*p-- = '\0';
	NumofDigits = 0;
	/* Generate digits in reverse order. */
	do {
		if (NumofDigits++ >= 3) {
			*p-- = ',';
			NumofDigits = 1;
		}
		*p-- = v % 10 + '0';
	} while ((v /= 10) > 0);
	return (p+1);
}


/*
 *	Return pointer to 3.1m size conversion.
 */
static char *
FsizeToA(int64 v)		/* Value to convert. */
{
#define	EXA  (1024LL * 1024 * 1024 * 1024 * 1024 * 1024)
#define	PETA (1024LL * 1024 * 1024 * 1024 * 1024)
#define	TERA (1024LL * 1024 * 1024 * 1024)
#define	GIGA (1024LL * 1024 * 1024)
#define	MEGA (1024LL * 1024)
#define	KILO (1024LL)

	static char buf[32];
	char		*p;
	int		NumofDigits;

#if defined(FSIZEA_EXACT)
	sprintf(buf, "%lld", v);
	return (buf);
#endif /* defined(FSIZEA_EXACT) */

	p = buf + sizeof (buf) - 1;
	*p-- = '\0';
	NumofDigits = 0;
	if (v >= EXA) {
		*p-- = 'E';
		v = (v + (5 * EXA/100)) / (EXA / 10);
	} else if (v >= PETA) {
		*p-- = 'P';
		v = (v + (5 * PETA/100)) / (PETA / 10);
	} else if (v >= TERA) {
		*p-- = 'T';
		v = (v + (5 * TERA/100)) / (TERA / 10);
	} else if (v >= GIGA) {
		*p-- = 'G';
		v = (v + (5 * GIGA/100)) / (GIGA / 10);
	} else if (v >= MEGA) {
		*p-- = 'M';
		v = (v + (5 * MEGA/100)) / (MEGA / 10);
	} else if (v >= KILO) {
		*p-- = 'k';
		v = (v + (5 * KILO/100)) / (KILO / 10);
	} else {
		*p-- = ' ';
		*p-- = ' ';
		*p-- = ' ';
		NumofDigits = 2;
	}

	/* Generate digits in reverse order. */
	do {
		if (NumofDigits++ == 1) {
			*p-- = '.';
		}
		*p-- = v % 10 + '0';
	} while ((v /= 10) > 0);
	return (p+1);
}


/*
 *	Print error message.
 */
static void
prerror(
	int status,
	int prerrno,
	char *fmt,
	...)
{
	int	SaveErrno;
	va_list	ap;

	if (Quiet && 0 == status)
		return;
	SaveErrno = errno;
	fprintf(stderr, "%s: ", program_name);
	if (fmt != NULL) {
		va_start(ap, fmt);
		vfprintf(stderr, fmt, ap);
		va_end(ap);
	}
	if (prerrno) {
		char *p;

		if ((p = strerror(SaveErrno)) != NULL)
			fprintf(stderr, ": %s", p);
		else fprintf(stderr, ": Error number %d", SaveErrno);
	}
	fprintf(stderr, "\n");
	fflush(stderr);
	if (status)  exit(status);
	exit_status = EXIT_FAILURE;
}
