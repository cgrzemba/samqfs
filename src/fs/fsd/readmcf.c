/*
 * read_mcf.c  - Read and process mcf file.
 *
 *		Description:
 *			Reads and processes the mcf file.
 *
 *          In the MCF file the first 3 parameters (device_name,
 *          equipment ordinal, and device type) are required.  For
 *          robotic devices, the catalog file is also required.
 *          A minus (-) may be used as a place holder when the parameter
 *          need not be specified.
 *
 *      On return:
 *          DeviceTable = Array of device entries as defined in sam_device.h.
 *			DeviceNumof = Number of entries in DeviceTable.
 *          MaxDevEq    = The highest equipment ordinal found.
 *
 *      Returns:
 *          None.  Error exit if errors occurred.
 *
 *      Example MCF file:
 *          device_name         eq      type    set     state   catalog
 *          /dev/rdsk/c1t1d0s0  3       o2      rapid1
 *          /dev/sam/rapid1     4       rc      rapid1  -       /etc/rapid1.cat
 *          /dev/rdsk/c0t4d0s0  5       mf      -
 *          /dev/sam/samfs      10      ms      samfs   on
 *          /dev/dsk/c0t0d0s5   11      md      samfs   on
 *          /dev/dsk/c0t0d0s6   12      md      samfs   on
 */

/*
 *    SAM-QFS_notice_begin
 *
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License (the "License").
 * You may not use this file except in compliance with the License.
 *
 * You can obtain a copy of the license at pkg/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at pkg/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */
/*
 * Copyright 2008 Sun Microsystems, Inc.  All rights reserved.
 * Use is subject to license terms.
 *
 *    SAM-QFS_notice_end
 */

#pragma ident "$Revision: 1.38 $"

static char *_SrcFile = __FILE__;
/* Using __FILE__ makes duplicate strings */

/* ANSI C headers. */
#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/* POSIX headers. */
#include <unistd.h>

/* Solaris headers. */
#include <syslog.h>

/* SAM-FS headers. */
#include "sam/types.h"
#include "pub/devstat.h"
#include "sam/devnm.h"
#include "sam/mount.h"
#include "sam/lib.h"
#include "sam/readcfg.h"
#include "sam/sam_malloc.h"
#include "sam/custmsg.h"

/* Local headers. */
#include "fsd.h"

extern char *getfullrawname();

/* Private functions. */
static void McfLine(void);
static int nm_to_dtclass(char *nm);

/* Command table */
static DirProc_t dirProcTable[] = {
	{ NULL, McfLine, DP_other }
};

static char dirname[TOKEN_SIZE];
static char token[TOKEN_SIZE];

static boolean_t histFound;	/* Set if an historian is defined */

#ifdef linux
void
CheckMcf(char *mcf_name) {
	int   err;

	/* if mcf is in default loc check to see if it was autogenerated */
	if (strcmp("/etc/opt/SUNWsamfs/mcf", mcf_name) == 0) {
		err = system("/opt/SUNWsamfs/tools/check_mcf.pl");
	}
}
#endif

void
ReadMcf(char *mcf_name)
{
	dev_ent_t *dev;			/* Device entry being composed */
	int		i;
	int		errors;
	char		msg_buf[MAX_MSGBUF_SIZE];

	RmediaDeviceCount = 0;
	SamRemoteServerCount = 0;
	DeviceNumof = 0;
	MaxDevEq = 0;
	histFound = FALSE;
#ifdef linux
	CheckMcf(mcf_name);
#endif
	errors = ReadCfg(mcf_name, dirProcTable, dirname, token,
	    ConfigFileMsg);
	if (errors != 0) {
		if (errors > 0) {
			errno = 0;
		}
		if (Daemon) {
			int		saveErrno;

			saveErrno = errno;
			(void) unlink(SAM_VARIABLE_PATH"/mcf.bin");
			errno = saveErrno;
		}
		snprintf(msg_buf, sizeof (msg_buf), GetCustMsg(14013),
		    mcf_name);
		PostEvent(FSD_CLASS, "CfgErr", 14013, LOG_ALERT, msg_buf,
		    NOTIFY_AS_FAULT | NOTIFY_AS_TRAP);
		FatalError(17209, mcf_name);
	}

	/*
	 * Set family set equipment ordinal for family set members (same name).
	 */
	for (i = 0; i < DeviceNumof; i++) {
		int		j;

		dev = &DeviceTable[i];
		if (*dev->set == '\0') {
			continue;
		}

		if ((dev->type & DT_FAMILY_SET) == DT_FAMILY_SET ||
		    dev->equ_type == DT_PSEUDO_SS) {
			dev->fseq = dev->eq;
			continue;
		}
		for (j = 0; j < DeviceNumof; j++) {
			dev_ent_t *dp;

			dp = &DeviceTable[j];
			if ((dp->type & DT_FAMILY_SET) == DT_FAMILY_SET &&
			    strcmp(dp->set, dev->set) == 0) {
				dev->fseq = dp->eq;
				break;
			}
		}
		if (j >= DeviceNumof) {
			/* No family set device for eq %d, set '%s' */
			ReadCfgError(17240, dev->eq, dev->set);
			errors++;
		}
	}
	if (errors != 0) {
		if (errors != 1) {
			/* %d errors in configuration file %s */

			/* send a sysevent for trap/fault history */
			snprintf(msg_buf, sizeof (msg_buf),
			    GetCustMsg(14000), errors, mcf_name);
			PostEvent(FSD_CLASS, "CfgErr", 14000, LOG_ALERT,
			    msg_buf, NOTIFY_AS_FAULT | NOTIFY_AS_TRAP);

			ReadCfgError(14000, errors, mcf_name);
		} else {
			/* 1 error in configuration file %s */

			/* send a sysevent for trap/fault history */
			snprintf(msg_buf, sizeof (msg_buf),
			    GetCustMsg(14001), mcf_name);
			PostEvent(FSD_CLASS, "CfgErr", 14001, LOG_ALERT,
			    msg_buf, NOTIFY_AS_FAULT | NOTIFY_AS_TRAP);

			ReadCfgError(14001, mcf_name);
		}
		FatalError(17209, mcf_name);
	}

	/*
	 * Count removable media devices (RmediaDeviceCount) and
	 * sam-remote server (SamRemoteServerCount).
	 */
	for (i = 0; i < DeviceNumof; i++) {

		dev = &DeviceTable[i];
		if ((IS_ROBOT(dev) || dev->type == DT_PSEUDO_SC ||
		    dev->fseq == 0) &&
		    dev->type != DT_HISTORIAN) {
			RmediaDeviceCount++;
		}
		if (dev->type == DT_PSEUDO_SS) {
			SamRemoteServerCount++;
		}
	}


	/*
	 * Add historian if not previously defined.
	 */
	if (!QfsOnly && !histFound && errors == 0 && RmediaDeviceCount > 0) {
		DeviceNumof++;
		SamRealloc(DeviceTable, DeviceNumof * sizeof (dev_ent_t));
		dev = &DeviceTable[DeviceNumof - 1];
		memset(dev, 0, sizeof (dev_ent_t));
		MaxDevEq++;
		strncpy(dev->name, "historian", sizeof (dev->name));
		dev->eq = dev->fseq = (equ_t)MaxDevEq;
		dev->type = dev->equ_type = DT_HISTORIAN;
		dev->state = DEV_ON;
		strncpy(dev->dt.rb.name, "historian", sizeof (dev->dt.rb.name));
	}
}


/*
 * Process mcf line.
 */
static void
McfLine(void)
{
	dev_ent_t dev;			/* Device entry being composed */
	char	*p;
	int		i;
	long	val;

	memset(&dev, 0, sizeof (dev));
	dev.state = DEV_ON;

	/*
	 * Device name.
	 */
	if (strlen(dirname) > sizeof (dev.name) - 1) {
		/* Device path name '%s' exceeds %d characters */
		ReadCfgError(17241, dirname, sizeof (dev.name) - 1);
	}
	strcpy(dev.name, dirname);
	/*
	 * Verify unique device name.
	 */
	for (i = 0; i < DeviceNumof; i++) {
		if (strcmp(DeviceTable[i].name, dev.name) == 0) {
			if ((strcmp(dev.name, "nodev")) != 0) {
				/* Equip name '%s' already in use by eq %d */
				ReadCfgError(17242, dev.name,
				    DeviceTable[i].eq);
			}
		}
	}

	/*
	 * Equipment ordinal.
	 */
	if (ReadCfgGetToken() == 0) {
		/* Equipment ordinal missing */
		ReadCfgError(17243);
	}
	errno = 0;
	val = strtoll(token, &p, 10);
	if (*p != '\0' || errno != 0) {
		/* Invalid equipment ordinal '%s' */
		ReadCfgError(17244, token);
	}
	if (val == 0 || val > EQU_MAX) {
		/* Equip ordinal %d must be in the range 1 <= eq_ord <= %d */
		ReadCfgError(17245, val, EQU_MAX);
	}
	dev.eq = (equ_t)val;
	/*
	 * Verify unique equipment ordinal.
	 */
	for (i = 0; i < DeviceNumof; i++) {
		if (DeviceTable[i].eq == dev.eq) {
			/* Equipment ordinal %d already in use */
			ReadCfgError(17246, dev.eq);
		}
	}

	/*
	 * Device type mnemonic.
	 * The device type is converted to the generic "rb", "tp",
	 * or "od" if the device is part of that class.
	 * This is for simpler configuring and avoids complaining
	 * about minor configuration problems that are automatically
	 * solved when the device is probed later on.
	 */
	if (ReadCfgGetToken() == 0) {
		/* Device type missing */
		ReadCfgError(17247);
	}
	dev.type = dev.equ_type = nm_to_dtclass(token);
	if (dev.type == 0) {
		/* Invalid device type '%s' */
		ReadCfgError(17248, token);
	}
#if defined(__i386) || defined(__amd64)
	if (dev.type == DT_OPTICAL) {
		/* Invalid device type '%s' */
		ReadCfgError(17248, token);
	}
#endif
	if (dev.type == DT_HISTORIAN) {
		if (histFound) {
			/* Only one historian allowed '%s' */
			ReadCfgError(17249, token);
		}
		histFound = TRUE;
	}

	/*
	 * Family set name.
	 */
	if (ReadCfgGetToken() != 0 && strcmp(token, "-") != 0) {
		if (strlen(token) > sizeof (dev.set) - 1) {
			ReadCfgError(17250, token, sizeof (dev.set) - 1);
		}
		strncpy(dev.set, token, sizeof (dev.set));
	}

	/*
	 * Device state.
	 */
	if (ReadCfgGetToken() != 0 && strcmp(token, "-") != 0) {
		for (i = 0; dev_state[i] != NULL; i++) {
			if (strcmp(dev_state[i], token) == 0) {
				dev.state = i;
				break;
			}
		}
		if (dev_state[i] == NULL) {
			/* Invalid device state '%s' */
			ReadCfgError(17251, token);
		}
	}

	/*
	 * Catalog file or raw device path.
	 */
	if (ReadCfgGetToken() != 0 && strcmp(token, "-") != 0) {
		if (strlen(token) > sizeof (upath_t) - 1) {
			/* Path name '%s' exceeds %d characters */
			ReadCfgError(17252, token, sizeof (upath_t) - 1);
		}
		switch (dev.type & DT_CLASS_MASK) {
		case DT_PSEUDO:
			if (dev.type != DT_HISTORIAN) {
				break;
			}
			/* FALLTHROUGH */

		case DT_ROBOT:
			strcpy(dev.dt.rb.name, token);
			break;

		case DT_TAPE:
			strcpy(dev.dt.tp.samst_name, token);
			break;

		case DT_DISK:
		case DT_OBJECT_DISK: {
#ifdef sun
			char *rdsk;

			/*
			 * Compare token to dev.name, ensure they're related
			 * even though it is not used. This is a backward
			 * compatibility issue for Solaris only.
			 */
			if ((rdsk = getfullrawname(dev.name))) {
				if (strncmp(rdsk, token, sizeof (dev.name)) !=
				    0) {
					/* Raw dev name doesn't match dev */
					ReadCfgError(17258, token, dev.name);
				}
				free(dev.name);
			}
#endif
			break;
		}

		case DT_FAMILY_SET:
			strcpy(dev.dt.sc.name, token);
			break;

		default:
			if (dev.type == DT_PSEUDO_SC) {
				strcpy(dev.dt.sc.name, token);
			}
			break;
		}
	}

	/*
	 * Near-line robots or disk configuration.
	 */
	if (ReadCfgGetToken() != 0) {
#if defined(ROBOT_MASK)
		/* What isthis?? */
		dev.nrobots = 0;
		while (cp = strtok(token, ",")) {
			strcpy(dev.robot[dev.nrobots++], cp);
		}
#endif
		/* Extra fields on line */
		ReadCfgError(17253);
	}

	if ((dev.type & DT_FAMILY_SET) == DT_FAMILY_SET) {
		if (*dev.set == '\0') {
			/* Family set name missing */
			ReadCfgError(17254);
		}
		/*
		 * Verify unique family set name.
		 */
		for (i = 0; i < DeviceNumof; i++) {
			if (strcmp(DeviceTable[i].set, dev.set) == 0) {
				/* Family set name '%s' in use by eq %d */
				ReadCfgError(17255, dev.set,
				    DeviceTable[i].eq);
			}
		}
		if (dev.type == DT_DISK_SET &&
		    strcmp(dev.name, dev.set) != 0) {
			/* Device name '%s' must match family set name '%s' */
			ReadCfgError(17256, dev.name, dev.set);
		}
	}

	/*
	 * Add device entry.
	 */
	if (dev.eq > (equ_t)MaxDevEq) {
		MaxDevEq = dev.eq;
	}
	DeviceNumof++;
	SamRealloc(DeviceTable, DeviceNumof * sizeof (dev));
	memmove(&DeviceTable[DeviceNumof - 1], &dev, sizeof (dev));
}


#define	is_scsi_robot(a)	(((a) & DT_SCSI_ROBOT_MASK) == DT_SCSI_R)
#define	is_scsi_tape(a)		(is_tape(a))

/*
 * nm_to_dtclass.c  - Check legality of device mnemonic
 *
 * Description:
 *     Convert two character device mnemonic to device type.
 *          If the device is any of the scsi robots or optical devices,
 *          return the generic type for scsi robots or optical. (rb or od)
 *          If the device is a scsi tape and uses the standard st device
 *          driver, return the device type for standard tape. (tp)
 *
 * On entry:
 *     nm  = The mnemonic name for the device.
 *
 * Returns:
 *     The device type or 0 if the mnemonic is not recognized.
 *
 */

static int
nm_to_dtclass(char *nm)
{					/* Device mnemonic */
	int i, dt;
	char *nmp = nm + 1;

	if (*nm == 'z') {
		dt = DT_THIRD_PARTY | (*(++nm) & 0xff);
		return (dt);
	}

	/* Striped groups - g0 - g127 */
	if (*nm == 'g' && *nmp >= '0' && *nmp <= '9') {
		dt = strtol(nmp, NULL, 10);
		if (dt < dev_nmsg_size) {
			dt = DT_STRIPE_GROUP | dt;
			return (dt);
		}
	}

	/* Target groups - o0 - o127 */
	if (*nm == 'o' && *nmp >= '0' && *nmp <= '9') {
		dt = strtol(nmp, NULL, 10);
		if (dt >= 0 && dt < dev_nmog_size) {
			dt = DT_OBJECT_DISK | dt;
			return (dt);
		}
	}
	for (i = 0; i >= 0; i++) {
		if (dev_nm2dt[i].dt == 0)
			return (0);
		if (strcmp(nm, dev_nm2dt[i].nm) == 0)
			break;
	}

	dt = dev_nm2dt[i].dt;
	if (is_scsi_tape(dt))
		return (DT_TAPE);
	if (is_scsi_robot(dt))
		return (DT_ROBOT);
	if (is_optical(dt))
		return (DT_OPTICAL);

	return (dt);
}
