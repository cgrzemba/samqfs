/*
 *    SAM-QFS_notice_begin
 *
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License (the "License").
 * You may not use this file except in compliance with the License.
 *
 * You can obtain a copy of the license at pkg/OPENSOLARIS.LICENSE
 * or https://illumos.org/license/CDDL.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at pkg/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */
/*
 * Copyright 2009 Sun Microsystems, Inc.  All rights reserved.
 * Use is subject to license terms.
 *
 *    SAM-QFS_notice_end
 */


#ifndef SCRKD_H
#define	SCRKD_H

#pragma ident	"$ID$"

#include <sys/types.h>

/* Logging setup */
#include "sam/sam_trace.h"
#define	_LOG  _Trace
#define	ERR_LVL TR_ERR
#define	MSG_LVL TR_MISC
#define	DBG_LVL TR_DEBUG


#define	MAX_ASSET_ID		256
#define	MAX_ADDITIONAL_INFO	4000
#define	CNS_DATA_DIR		"/etc/opt/SUNWsamfs/csn"
#define	CNS_CONF		CNS_DATA_DIR"/target.conf"
#define	CNS_ASSETDIR_SPEC	CNS_DATA_DIR"/%s/"
#define	CNS_CLIENTDATA_SPEC	CNS_ASSETDIR_SPEC"client.conf"
#define	CNS_CLPRIVKEYPATH_SPEC	CNS_ASSETDIR_SPEC"key.priv"
#define	CNS_CLPUBKEYPATH_SPEC	CNS_ASSETDIR_SPEC"key.pub"
#define	CNS_PUBLIC		CNS_DATA_DIR"/key.pub"
#define	CNS_PRIVATE		CNS_DATA_DIR"/key.priv"
#define	CNS_CLIENT_CONF		"client.conf"


#define	XML_REG_FILE_SPEC	CNS_ASSETDIR_SPEC"regstr.xml"
#define	XML_TELEM_FILE_SPEC	CNS_ASSETDIR_SPEC"telem.xml"
#define	XML_HRTBT_FIL_SPEC	CNS_ASSETDIR_SPEC"hrtbeat.xml"

#define	CLIENT_REGISTRATION_URL \
	"https://cns-services.sun.com/SCRK/ClientRegistrationV1_1_0"
#define	PRODUCT_REGISTRATION_URL \
	"https://cns-services.sun.com/SCRK/ClientTelemetryV1_1_0"

#define	CURL_DBG_FILE	"/tmp/curl.log"
#define	FORMDATA_CONTENT_TYPE		"multipart/form-data"
#define	REGSTR_PRODUCT_OFFER_CLASS	"SCRK_SIMPLE_PRODUCT_REGISTRATION"
#define	REGSTR_TELEMETRY_OFFER_CLASS	"DMG_SCRK_SIMPLE_MESSAGE_1_0"



/*
 * There are two classes of errors that we can encounter during registration.
 * 1. Errors that the users might have induced or could fix
 *	1a. Curl/SSL problems (problem with data dir, bad proxy etc.
 *	1b. Authentication errors returned by the CSN servers.
 * 2. Internal errors.
 *
 * For errors of the first class we want to try to explain what might be
 * the problem so that they can fix it.
 *
 * For errors of the second class we want to give a general failure message
 * that indicates that registration is not required for them to use their
 * software. The specific (and more cryptic) errors should be traced
 * This class of error will simply result in a -1.
 *
 */
#define	SCRK_ERR_START 30710
typedef enum scrk_errnos {
	SCRK_CANT_WRITE_TO_DATA_DIR = SCRK_ERR_START,
	SCRK_CANT_READ_DATA,
	SCRK_AUTHENTICATION_FAILED,
	SCRK_REG_SERVER_FAILURE,
	SCRK_COULDNT_RESOLVE_PROXY,
	SCRK_COULDNT_RESOLVE_HOST,
	SCRK_BAD_SERVER_CERTIFICATE,
	SCRK_OPERATION_TIMED_OUT,
} scrk_errnos_t;

/* Struct to hold swordfish product ids */
typedef struct sf_prod_info {
	char *name;
	char *id;
	char *descr;
	char *version;
	char *vendor;
	char *vendor_id;
	char *additional_info;
} sf_prod_info_t;


/* Proxy Configuration */
typedef struct proxy_cfg {
	boolean_t	enabled;
	boolean_t	auth;
	char		*host;
	char		*port;
	char		*user;
	char		*passwd;
} proxy_cfg_t;


/*
 * Struct to hold information related to a client
 * registration
 *
 * asset_prefix is mandatory it acts as a key for the later
 * retrieval of information for communication.
 *
 * if asset_id is not populated it will be generated by appending host
 * identifying information to the asset_prefix.
 */
typedef struct cl_reg_cfg {
	char		*sun_login;
	char		*name;
	char		*email;
	char		*asset_prefix;
	char		*asset_id;
	char		*reg_id;	/* Client reg id */
	boolean_t	registered;	/* Product reg status */
	proxy_cfg_t	prxy;
} cl_reg_cfg_t;


/*
 * generate and store a pair of RSA keys in the asset directory
 */
int
regstr_generate_public_private_key(char *asset_prefix);

/*
 * Register the client
 *
 * if cl->asset_id is null an asset id will be generated by appending
 * system identifying information to the asset prefix. cl->asset_id will
 * hold the malloced asset id on return.
 *
 * Returns 0 if successful and sets cl->reg_id to the clients
 * registration id.
 */
int
regstr_postclient_regis_data(cl_reg_cfg_t *cl, char *sunpasswd);

/*
 * Register the product for the client.
 *
 * Builds the product registration xml from the sf and cl
 * structs and saves the result in a file at XML_REG_FILE_SPEC
 */
int
regstr_postproduct_regis_data(sf_prod_info_t *sf, cl_reg_cfg_t *cl);


/*
 * proposed telemetry function for future use
 */
int
regstr_send_fault_telem_data(sf_prod_info_t *sf, int subsys, int slevel,
    char *subject, char *problem, char *action, int mesgid);


/*
 * Generate a pair of Diffie Hellman keys based on the preset
 * params and return the malloced public key in a hex string and
 * a signature that can be used to verify the key.
 */
int get_public_key(char **hexpubkey, unsigned char **sig, int *sig_len);


/*
 * Generate a pair of Diffie Hellman keys based on the preset
 * params and return the public key in a hex string.
 */
int get_secret(char *remote_public, unsigned char **secret);


/*
 * decrypt the cipher text and return a malloced buffer containing
 * the plain text. This function will return a null terminated string
 */
int decrypt_string(char **plain_text, unsigned char *secret,
    unsigned char *cipher_text, int cipher_text_len);

/*
 * encrypt the plain text and return a malloced buffer containing the
 * cipher text.
 */
int encrypt_string(char *plain_text, unsigned char *secret,
    unsigned char **cipher_text, int *cipher_text_len);


/*
 * Return 0 if the required fields are set otherwise return -1
 * Note:
 * reg_id is required unless for_initial_reg is B_TRUE.
 *
 * This function calls check_proxy_cfg
 */
int check_cl_reg_cfg(const cl_reg_cfg_t *cl, const boolean_t for_initial_reg);


/*
 * Return 0 if the required fields are set otherwise return -1.
 * Note:
 * host and port are only required if enabled is B_TRUE.
 * user and passwd are only required if auth is B_TRUE.
 */
int check_proxy_cfg(const proxy_cfg_t *prxy);


/*
 * return 0 if the required fields are non-null otherwise return -1
 */
int check_sf_prod_info(const sf_prod_info_t *sf);


/*
 * free the product info and all non-null fields
 */
void free_sf_prod_info(sf_prod_info_t *sf);


/*
 * free all non-null fields and cl
 */
void free_cl_reg_cfg(cl_reg_cfg_t *cl);


/*
 * free all non-null fields but not cl
 */
void free_cl_reg_cfg_fields(cl_reg_cfg_t *cl);


/*
 * zero and free a buffer containing sensitive information
 */
void free_sensitive_buf(char **buf, int buf_len);

#endif /* SCRKD_H */
